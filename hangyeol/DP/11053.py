# 가장 긴  증가하는 부분 수열
'''
https://www.acmicpc.net/problem/11053
배열이 주어졌을 때  
가능한 부분 수열 중 가장 길게 증가하는 부분 수열 구하기

모든 인덱스에서 최악의 경우 부분 수열의 최대 길이는 모두 1이다 따라서 초기 값을 1로 설정  
예를 들어, arr = [0,0,0,0,0] 이면 증가하는 부분 수열은 찾을 수 없으므로
부분 수열을 최대 길이는 1이다 

반복문을 통해 l 기준 증가하는 수열을 길이를 d에 기록하자  
arr[l] < arr[r] 이면 d[r] = d[l] + 1 해주는거 
r은 l+1 부터 N-1
i   |  0  1  2  3  4  5
arr | 10 20 10 30 20 50
d   |  1  2  1  2  2  2
       l  

i   |  0  1  2  3  4  5
arr | 10 20 10 30 20 50
d   |  1  2  1  3  2  3
          l 

근데 이미 기록된 값이 더 큰 경우가 있다 
이때는 기록된 값을 그대로 둬야한다 (이전에 기록된 그 자리에서의 부분 수열 최대 길이이기 때문)
i   |  0  1  2  3  4  5
arr | 10 20 10 30 20 50
d   |  1  2  1  3  2  3
             l

i   |  0  1  2  3  4  5
arr | 10 20 10 30 20 50
d   |  1  2  1  3  2  4
                l
'''

# 수열의 크기 
N = int(input())

# 수열 입력 받기 
arr = list(map(int,input().split()))

# 각 인덱스까지에서의 가장 긴 증가하는 부분수열의 길이
d = [1 for _ in range(N)] # 수열의 길이, 증가량 / 모두 증가하는 수열이 아닐 때 부분수열의 길이는 1이므로 초기값 1로 설정 

# 반복문을 통해 탐색 시작 
for l in range(N): # arr[l] 기준 

    for r in range(l+1,N): # 비교 대상

        if arr[l] < arr[r] and d[l] + 1 > d[r]: # arr[l] 보다 크고 기록된 값이 기록할 값보다 작다면 
            d[r] = d[l] + 1

# print(d)
print(max(d))
